/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package paulousimulationcode;

import gui.animator;
import java.util.ArrayList;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JApplet;
import javax.swing.JFrame;

/**
 *
 * @author Zolotas
 */
public class Simulation extends Cycleable  {

    private Manet network = new Manet();
    private static Random rand = new Random();
    private JFrame frame;
    JApplet ap;

    @Override
    public void Cycle() {
        optimization();
        network.Cycle();
        for (Node n : network.getNodeSet()) {
            double next = rand.nextDouble();
            n.setComputingLoad(n.getComputingLoad() + next * 0.1 > 1 ? 1 : n.getComputingLoad() + next * 0.1);
            n.Cycle();
        }
        frame.repaint();
        frame.remove(ap);
        ap = new animator(network);
        ap.init();
        ap.start();
        frame.add("Center", ap);
        frame.pack();

        try {
            Thread.sleep(1);
        } catch (InterruptedException ex) {
            Logger.getLogger(Simulation.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public void init() {
        frame = new JFrame("Simulation Animation");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        ap = new animator(network);
        ap.init();
        ap.start();
        frame.add("Center", ap);
        frame.pack();
        frame.setVisible(true);
        
        Node in = new Node(rand.nextBoolean(), true, false, false, true, false, rand.nextDouble() * 2048 + 2048, rand.nextDouble() * 1 + 0.5, rand.nextDouble() * 3500 + 1050, 0, 0);
        in.setCurrentCF(Utilities.CF(in));
        network.getNodeSet().add(in);

        for (int i = 1; i < Utilities.sizeOfNodeSet; i++) {
            int role = rand.nextInt(4);
            Node n;
            switch (role) {
                case 0:
                    n = new Node(true, false, false, true, false, true, rand.nextDouble() * 1024 + 512, rand.nextDouble() * 2 + 0.5, rand.nextDouble() * 3500 + 1050, 0, 0);
                    n.setCurrentCF(Utilities.CF(n));
                    network.getNodeSet().add(n);
                    break;
                case 1:
                    n = new Node(true, false, false, false, true, false, rand.nextDouble() * 1024 + 512, rand.nextDouble() * 2 + 0.5, rand.nextDouble() * 3500 + 1050, 0, 0);
                    n.setCurrentCF(Utilities.CF(n));
                    network.getNodeSet().add(n);
                    break;
                default:
                    n = new Node(true, false, false, false, false, true, rand.nextDouble() * 1024 + 512, rand.nextDouble() * 2 + 0.5, rand.nextDouble() * 3500 + 1050, 0, 0);
                    n.setCurrentCF(Utilities.CF(n));
                    network.getNodeSet().add(n);
                    break;
            }
        }
        network.calculateNeighbours();
        for (int i = 1; i < Utilities.sizeOfNodeSet; i++) {
            if (network.getNodeSet().get(i).isClusterManager()) {
                boolean isThereAHead = false;
                for (int j = 1; j < network.getNodeSet().get(i).getNeighbours().size(); j++) {
                    if (network.getNodeSet().get(i).getNeighbours().get(j).isClusterHead()) {
                        isThereAHead = true;
                        break;
                    }
                }
                if (!isThereAHead) {
                    network.getNodeSet().get(i).setClusterHead(true);
                }
            }
        }

        for (int i = 1; i < Utilities.sizeOfNodeSet; i++) {
            if (network.getNodeSet().get(i).isClusterManager()) {
                for (int j = 1; j < network.getNodeSet().get(i).getNeighbours().size(); j++) {
                    for (int k = 1; k < network.getNodeSet().get(i).getNeighbours().size(); k++) {
                        if (j != k) {
                            if (!network.getNodeSet().get(i).getNeighbours().get(j).getNeighbours().contains(
                                    network.getNodeSet().get(i).getNeighbours().get(k))
                                    && !network.getNodeSet().get(i).getNeighbours().get(k).getNeighbours().contains(
                                            network.getNodeSet().get(i).getNeighbours().get(j))
                                    && network.getNodeSet().get(i).getNeighbours().get(j).isClusterManager()
                                    && network.getNodeSet().get(i).getNeighbours().get(k).isClusterManager()) {
                                network.getNodeSet().get(i).setClusterHead(true);
                            }
                        }
                    }
                }
            }
        }

    }

    public void optimization() {
        System.out.println("optimize");
        for (int i = 0; i < network.getNodeSet().size(); i++) {
            //System.out.println("first for for "+i);
            for (int j = 0; j < network.getNodeSet().size(); j++) {
                if (i != j) {
                    if (network.getNodeSet().get(i).getNeighbours().containsAll(network.getNodeSet().get(j).getNeighbours())
                            && network.getNodeSet().get(i).getCurrentCF() > network.getNodeSet().get(j).getCurrentCF()
                            && network.getNodeSet().get(i).isClusterHead()
                            && network.getNodeSet().get(j).isClusterHead()) {
                        network.getNodeSet().get(j).setClusterHead(false);
                        network.getNodeSet().get(j).setClusterNode(true);
                    }
                }
            }
        }
        for (int i = 0; i < network.getNodeSet().size(); i++) {
            //System.out.println("second for for "+i);
            for (int j = 0; j < network.getNodeSet().size(); j++) {
                for (int k = 0; k < network.getNodeSet().size(); k++) {
                    if (i != j && j != k && i != k) {
                        
                         //System.out.println("checking "+i+","+j+","+k);
                         
                        ArrayList union = (ArrayList)network.getNodeSet().get(i).getNeighbours().clone();
                        union.addAll(network.getNodeSet().get(j).getNeighbours());
                        // System.out.println("union contains "+union.size());
                       //  System.out.println("network.getNodeSet().get("+i+").getNeighbours() "+network.getNodeSet().get(i).getNeighbours().size());
                        // System.out.println("network.getNodeSet().get("+j+").getNeighbours() "+network.getNodeSet().get(j).getNeighbours().size());

                         
                        if (union.containsAll(network.getNodeSet().get(k).getNeighbours())
                                && network.getNodeSet().get(k).getCurrentCF() < network.getNodeSet().get(i).getCurrentCF()
                                && network.getNodeSet().get(k).getCurrentCF() < network.getNodeSet().get(j).getCurrentCF()
                                && network.getNodeSet().get(k).isClusterHead()
                                && network.getNodeSet().get(j).isClusterHead()
                                && network.getNodeSet().get(i).isClusterHead()) {
                            network.getNodeSet().get(k).setClusterHead(false);
                            network.getNodeSet().get(k).setClusterNode(true);
                        }
                    }
                }
                if (i != j) {
                    if (network.getNodeSet().get(i).getNeighbours().containsAll(network.getNodeSet().get(j).getNeighbours())
                            && network.getNodeSet().get(i).getCurrentCF() > network.getNodeSet().get(j).getCurrentCF()
                            && network.getNodeSet().get(i).isClusterHead()
                            && network.getNodeSet().get(j).isClusterHead()) {
                        network.getNodeSet().get(j).setClusterHead(false);
                        network.getNodeSet().get(j).setClusterNode(true);
                    }
                }
            }
        }
        System.out.println("EOoptimize");
    }
}
