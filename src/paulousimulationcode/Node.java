/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package paulousimulationcode;

import java.util.ArrayList;
import java.util.Random;

/**
 *
 * @author Zolotas
 */
public class Node extends Cycleable{
    private boolean ManagerNode;
    private boolean ClusterHead;
    private boolean ClusterNode;
    
    private boolean ClusterManager;
    private boolean TerminalModule;
    
    private Position position;
    
    private ArrayList<Node> neighbours;
    private ArrayList<Integer> mobilityInTime;
    
    private double memory;//in MB
    private double processor;//in GHz
    private double battery;//in mAh
    private double mobility;//in Custom Cowabanga units
    private double ComputingLoad; //in tasks i guess
    private boolean active;
    
    public double maxMemory;//in MB
    public static double maxProcessor=0;//in GHz
    public double maxBattery;//in mAh
    public double maxMobility;//in Custom Cowabanga units called neighbours'
    public double maxComputingLoad; //in tasks i guess
    private double currentCF=0;
    
    private boolean Moving;
    

    public Node(boolean Moving, boolean ManagerNode, boolean ClusterHead, boolean ClusterNode, boolean ClusterManager, boolean TerminalModule, double memory, double processor, double Battery, double mobility, double ComputingLoad) {
        this.active=true;
        this.Moving = Moving;
        this.ManagerNode = ManagerNode;
        this.ClusterHead = ClusterHead;
        this.ClusterNode = ClusterNode;
        this.ClusterManager = ClusterManager;
        this.TerminalModule = TerminalModule;
        this.memory = memory;
        this.processor = processor;
        this.battery = Battery;
        this.mobility = mobility;
        this.ComputingLoad = ComputingLoad;
        this.position = new Position(new Random().nextDouble()*Utilities.xBound,new Random().nextDouble()*Utilities.yBound,new Random().nextDouble()*Utilities.zBound);
        this.neighbours = new ArrayList<Node>();
        this.mobilityInTime = new ArrayList<Integer>();
        
        if(this.processor>maxProcessor){
            maxProcessor = this.processor;
        }
    }
    
    @Override
    public void Cycle(){
        if(Moving){
            position = new Position(Math.abs(position.getX()+new Random().nextDouble()-0.5)%Utilities.xBound,Math.abs(position.getY()+new Random().nextDouble()-0.5)%Utilities.yBound,Math.abs(position.getZ()+new Random().nextDouble()-0.5)%Utilities.zBound);
        }
        
        if(this.active){
            this.battery -= this.ComputingLoad;
        }
        if(battery<=0){
            active = false;
        }
        
        this.ComputingLoad *= Math.abs(new Random().nextDouble()-0.1);
        Utilities.calculateMobilityRatio(this);
        this.currentCF = Utilities.CF(this);
    }

    public double getCurrentCF() {
        return currentCF;
    }

    public void setCurrentCF(double currentCF) {
        this.currentCF = currentCF;
    }

    public boolean isActive() {
        return active;
    }

    public void setActive(boolean active) {
        this.active = active;
    }

    public double getMaxMemory() {
        return maxMemory;
    }

    public void setMaxMemory(double maxMemory) {
        this.maxMemory = maxMemory;
    }

    public ArrayList<Integer> getMobilityInTime() {
        return mobilityInTime;
    }

    public void setMobilityInTime(ArrayList<Integer> mobilityInTime) {
        this.mobilityInTime = mobilityInTime;
    }

    public double getMaxBattery() {
        return maxBattery;
    }

    public void setMaxBattery(double maxBattery) {
        this.maxBattery = maxBattery;
    }

    public double getMaxMobility() {
        return maxMobility;
    }

    public void setMaxMobility(double maxMobility) {
        this.maxMobility = maxMobility;
    }

    public double getMaxComputingLoad() {
        return maxComputingLoad;
    }

    public void setMaxComputingLoad(double maxComputingLoad) {
        this.maxComputingLoad = maxComputingLoad;
    }
    
    public boolean isMoving() {
        return Moving;
    }

    public void setMoving(boolean Moving) {
        this.Moving = Moving;
    }
    
    public double getMemory() {
        return memory;
    }

    public void setMemory(double memory) {
        this.memory = memory;
    }

    public double getProcessor() {
        return processor;
    }

    public void setProcessor(double processor) {
        this.processor = processor;
    }

    public double getBattery() {
        return battery;
    }

    public void setBattery(double Battery) {
        this.battery = Battery;
    }

    public double getMobility() {
        return mobility;
    }

    public void setMobility(double mobility) {
        this.mobility = mobility;
    }

    public double getComputingLoad() {
        return ComputingLoad;
    }

    public void setComputingLoad(double ComputingLoad) {
        this.ComputingLoad = ComputingLoad;
    }
    
    public boolean isManagerNode() {
        return ManagerNode;
    }

    public void setManagerNode(boolean ManagerNode) {
        this.ManagerNode = ManagerNode;
    }

    public boolean isClusterHead() {
        return ClusterHead;
    }

    public void setClusterHead(boolean ClusterHead) {
        this.ClusterHead = ClusterHead;
    }

    public boolean isClusterNode() {
        return ClusterNode;
    }

    public void setClusterNode(boolean ClusterNode) {
        this.ClusterNode = ClusterNode;
    }

    public boolean isClusterManager() {
        return ClusterManager;
    }

    public void setClusterManager(boolean ClusterManager) {
        this.ClusterManager = ClusterManager;
    }

    public boolean isTerminalModule() {
        return TerminalModule;
    }

    public void setTerminalModule(boolean TerminalModule) {
        this.TerminalModule = TerminalModule;
    }

    public Position getPosition() {
        return position;
    }

    public void setPosition(Position position) {
        this.position = position;
    }    

    public ArrayList<Node> getNeighbours() {
        return neighbours;
    }

    public void setNeighbours(ArrayList<Node> neighbours) {
        this.neighbours = neighbours;
    }
    
}
